---
title: "Hands-on Exercise 7: Visualising and Analysing Geographic Data"
author: "Rizqi Febriansyah"
date: "21 February 2023"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
editor: visual
---

# Part One: Choropleth Mapping with R

# 7.1 Overview

Choropleth mapping is a technique that uses patterns or colors to symbolize different areas, such as countries, provinces, states, counties, or census units. For instance, to illustrate the geographical distribution of Singapore's elderly population according to the Master Plan 2014 Subzone Boundary, a social scientist might employ a choropleth map. This chapter will guide you through the process of creating accurate and effective choropleth maps with the help of a tool known as the [tmap](https://cran.r-project.org/web/packages/tmap/) package in R.

::: callout-note
It is advisable for you to read the functional description of each function before using them.
:::

# 7.2 Getting Started

In this hands-on exercise, the primary R package we'll be utilising is the [tmap](https://cran.r-project.org/web/packages/tmap/) package. Alongside tmap, we'll also make use of four additional R packages, namely:

-   [readr](https://readr.tidyverse.org/), for importing delimited text files,
-   [tidyr](https://tidyr.tidyverse.org/), for organising data,
-   [dplyr](https://dplyr.tidyverse.org/), for manipulating data, and
-   [sf](https://cran.r-project.org/web/packages/sf/), for managing geospatial data.

It's worth noting that readr, tidyr, and dplyr are all components of the tidyverse package.

Below, you'll find the code snippet that will help you install and load these packages in RStudio.

```{r}
pacman::p_load(sf, tmap, tidyverse)
```

::: callout-note
Notice that, we only need to install **tidyverse** instead of readr, tidyr and dplyr individually.
:::

# 7.3 Importing Geospatial Data into R

## 7.3.1 The Data

To create the choropleth map, we will use two datasets:

1.  The "Master Plan 2014 Subzone Boundary (Web)" (abbreviated as `MP14_SUBZONE_WEB_PL`), available in ESRI shapefile format. This geospatial dataset outlines the geographical boundaries of Singapore at the planning subzone level, based on the Urban Redevelopment Authority's Master Plan 2014. It is accessible for download from [data.gov.sg](https://data.gov.sg/).

2.  "Singapore Residents by Planning Area/Subzone, Age Group, Sex, and Type of Dwelling, June 2011-2020" in CSV format (file name: respopagesextod2011to2020.csv). This dataset, which can be downloaded from the [Department of Statistics, Singapore](https://www.singstat.gov.sg/), is considered aspatial, meaning it lacks coordinate values. However, its PA and SZ fields serve as unique identifiers that allow for geocoding to the `MP14_SUBZONE_WEB_PL` shapefile.

## 7.3.2 Importing the data

The following code snippet employs the `st_read()` function from the sf package to load the MP14_SUBZONE_WEB_PL shapefile into R, where it is stored as a simple feature data frame named `mpsz`.

```{r}
mpsz <- st_read(dsn = "data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

You can examine the content of mpsz by using the code chunk below.

```{r}
mpsz
```

Notice that only the first ten records will be displayed. Do you know why?

## 7.3.3 Importing Attribute Data into R

Following this, we'll proceed to load the `respopagsex2011to2020.csv` file into RStudio, storing it in an R dataframe named `popagsex`.

This operation will be executed using the `read_csv()` function from the readr package, as illustrated in the code snippet below.

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2011to2020.csv")
```

## 7.3.4 Data Preparation

Before creating a thematic map, it is necessary to compile a data table focusing on the year 2020. This table needs to encompass several variables: PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, and DEPENDENCY.

-   YOUNG refers to the population in the age groups from 0-4 up to 20-24.
-   ECONOMY ACTIVE encompasses individuals in the age groups from 25-29 to 60-64.
-   AGED includes those aged 65 and above.
-   TOTAL represents the sum of all age groups.
-   DEPENDENCY calculates the ratio of the sum of YOUNG and AGED populations to the ECONOMY ACTIVE population.

### 7.3.4.1 Data Wrangling

The data manipulation and transformation tasks will involve the use of the following functions:

-   `pivot_wider()` from the tidyr package, and
-   `mutate()`, `filter()`, `group_by()`, and `select()` from the dplyr package.

```{r}
popdata2020 <- popdata %>%
  filter(Time == 2020) %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup() %>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)
```

### 7.3.4.2 Joining the attribute data and geospatial data

Before proceeding with the georelational join, we must undertake an additional step of converting the values in the PA and SZ fields to uppercase. This step is necessary due to the mixed use of upper- and lowercase letters in the PA and SZ fields, whereas the SUBZONE_N and PLN_AREA_N fields are consistently in uppercase.

```{r}
popdata2020 <- popdata2020 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = funs(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

Next, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier.

```{r}
mpsz_pop2020 <- left_join(mpsz, popdata2020,
                          by = c("SUBZONE_N" = "SZ"))
```

Key takeaway from the above code snippet:

The `left_join()` function from the dplyr package is applied, with the `mpsz` simple feature data frame designated as the left table. This approach guarantees that the resulting output will maintain its structure as a simple features data frame.

```{r}
write_rds(mpsz_pop2020, "data/rds/mpszpop2020.rds")
```

# 7.4 Choropleth Mapping Geospatial Data Using tmap

There are two methods for creating thematic maps with tmap:

1.  Generating a thematic map swiftly using the `qtm()` function.
2.  Creating a highly customizable thematic map by employing various tmap elements.

## 7.4.1 Plotting a choropleth map quickly by using qtm()

The simplest and fastest way to create a choropleth map with tmap is through the use of `qtm()`. This approach is straightforward and often yields a visually appealing default representation.

Below, the code snippet will produce a choropleth map adhering to cartographic standards.

```{r}
tmap_mode("plot")
qtm(mpsz_pop2020, 
    fill = "DEPENDENCY")
```

Key insights from the provided code snippet include:

-   The function `tmap_mode()` is utilised with the option "plot" to generate a static map. To create an interactive map, the "view" option would be selected.
-   The `fill` parameter is employed to visually represent a specific attribute, in this case, "DEPENDENCY".

## 7.4.2 Creating a choropleth map by using tmap's elements

While `qtm()` offers a convenient and quick way to produce a choropleth map, its drawback lies in the limited control over the aesthetics of individual layers. For creating a high-quality cartographic choropleth map, as illustrated in the figure below, it's recommended to utilise the drawing elements provided by tmap.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "Dependency ratio") +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

In the following sub-section, we will share with you tmap functions that used to plot these elements.

## 7.4.2.1 Drawing a base map

The fundamental component of tmap is the `tm_shape()` function, which is then complemented by one or more layer elements like `tm_fill()` and `tm_polygons()`.

In the following code snippet, `tm_shape()` specifies the input data (i.e., mpsz_pop2020), and `tm_polygons()` is employed to render the polygons of the planning subzones.

```{r}
tm_shape(mpsz_pop2020) +
  tm_polygons()
```

## 7.4.2.2 Drawing a choropleth map using tm_polygons()

To draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().

```{r}
tm_shape(mpsz_pop2020)+
  tm_polygons("DEPENDENCY")
```

Things to learn from tm_polygons():

The default interval binning used to draw the choropleth map is called "pretty". A detailed discussion of the data classification methods supported by tmap will be provided in sub-section 4.3. The default colour scheme used is YlOrRd of ColorBrewer. You will learn more about the color scheme in sub-section 4.4. By default, Missing value will be shaded in grey.

## 7.4.2.3 Drawing a choropleth map using tm_fill() and \*tm_border()\*\*

Actually, tm_polygons() is a wraper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the shapefile onto the choropleth map.

The code chunk below draws a choropleth map by using tm_fill() alone.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY")
```

Notice that the planning subzones are shared according to the respective dependecy values

To add the boundary of the planning subzones, tm_borders will be used as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY") +
  tm_borders(lwd = 0.1,  alpha = 1)
```

Notice that light-gray border lines have been added on the choropleth map.

The alpha argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).

Beside alpha argument, there are three other arguments for tm_borders(), they are:

col = border colour, lwd = border line width. The default is 1, and lty = border line type. The default is "solid".

# 7.4.3 Data classification methods of tmap

Most choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.

tmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.

To define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.

### 7.4.3.1 Plotting choropleth maps with built-in classification methods

The code chunk below shows a quantile data classification that used 5 classes.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "jenks") +
  tm_borders(alpha = 0.5)
```

In the code chunk below, equal data classification method is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5)
```

Notice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.

### 7.4.3.2 Plotting choropleth map with custome break

For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).

Before we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.

```{r}
summary(mpsz_pop2020$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

Now, we will plot the choropleth map by using the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +
  tm_borders(alpha = 0.5)
```

## 7.4.4 Colour Scheme

tmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.

### 7.4.4.1 Using ColourBrewer palette

To change the colour, we assign the preferred colour to palette argument of tm_fill() as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 6,
          style = "quantile",
          palette = "Blues") +
  tm_borders(alpha = 0.5)
```

Notice that the choropleth map is shaded in green.

To reverse the colour shading, add a "-" prefix.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Greens") +
  tm_borders(alpha = 0.5)
```

Notice that the colour scheme has been reversed.

## 7.4.5 Map Layouts

Map layout refers to the combination of all map elements into a cohensive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Colour settings and data classification methods covered in the previous section relate to the palette and break-points are used to affect how the map looks.

### 7.4.5.1 Map Legend

In tmap, several legend options are provided to change the placement, format and appearance of the legend.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "jenks", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Jenks classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45, 
            legend.width = 0.35,
            legend.outside = FALSE,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```

### 7.4.5.2 Map style

tmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().

The code chunk below shows the classic style is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "-Greens") +
  tm_borders(alpha = 0.5) +
  tmap_style("classic")
```

### 7.4.5.3 Cartographic Furniture

Beside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below, tm_compass(), tm_scale_bar() and tm_grid() are used to add compass, scale bar and grid lines onto the choropleth map.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "No. of persons") +
  tm_layout(main.title = "Distribution of Dependency Ratio \nby planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

To reset the default style, refer to the code chunk below.

```{r}
tmap_style("white")
```

## 7.4.6 Drawing Small Multiple Choropleth Maps

Small multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

In tmap, small multiple maps can be plotted in three ways:

-   by assigning multiple values to at least one of the asthetic arguments,
-   by defining a group-by variable in tm_facets(), and
-   by creating multiple stand-alone maps with tmap_arrange().

### 7.4.6.1 By assigning multiple values to at least one of the aesthetic arguments

In this example, small multiple choropleth maps are created by defining ncols in tm_fill()

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill(c("YOUNG", "AGED"),
          style = "equal", 
          palette = "Blues") +
  tm_layout(legend.position = c("right", "bottom")) +
  tm_borders(alpha = 0.5) +
  tmap_style("white")
```

In this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments

```{r}
tm_shape(mpsz_pop2020)+ 
  tm_polygons(c("DEPENDENCY","AGED"),
          style = c("equal", "quantile"), 
          palette = list("Blues","Greens")) +
  tm_layout(legend.position = c("right", "bottom"))
```

### 7.4.6.2 By defining a group-by variable in tm_facets()

In this example, multiple small choropleth maps are created by using tm_facets().

```{r}
tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          thres.poly = 0) + 
  tm_facets(by="REGION_N", 
            free.coords=TRUE, 
            drop.shapes=FALSE) +
  tm_layout(legend.show = FALSE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(alpha = 0.5)
```

### 7.4.6.3 By creating multiple stand-alone maps with tmap_arrange()

In this example, multiple small choropleth maps are created by creating multiple stand-alone maps with tmap_arrange().

```{r}
youngmap <- tm_shape(mpsz_pop2020)+ 
  tm_polygons("YOUNG", 
              style = "quantile", 
              palette = "Blues")

agedmap <- tm_shape(mpsz_pop2020)+ 
  tm_polygons("AGED", 
              style = "quantile", 
              palette = "Blues")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```

# Part Two: Visualising Geospatial Point Data

# Overview

Proportional symbol maps, also referred to as graduated symbol maps, are a type of map that utilises the size of symbols to depict variations in the magnitude of a distinct, rapidly changing phenomenon, such as population counts. Similar to choropleth maps, these can be crafted in both classed and unclassed formats. The classed versions, known as range-graded or graduated symbols, organize data into categories, while unclassed versions, referred to as proportional symbols, directly relate the symbol's area to the attribute values being represented. In this practical exercise, you'll discover how to construct a proportional symbol map that illustrates the distribution of wins across Singapore Pools' outlets, using the tmap package in R.

# 8.1 Learning Outcome

Upon completing this practical exercise, you will have gained the following competencies through the use of suitable R packages:

-   Importing an aspatial data file into R.
-   Transforming the imported data into a simple point feature data frame, while also applying a suitable projection reference to this newly created data frame.
-   Creating interactive proportional symbol maps.

## Geting Started

Before we get started, we need to ensure that tmap package of R and other related R packages have been installed and loaded into R.

```{r}
pacman::p_load(sf, tmap, tidyverse)
```

# 8.2 Geospatial Data Wrangling

## 8.2.1 The data

The data set use for this hands-on exercise is called SGPools_svy21. The data is in csv file format.

Figure below shows the first 15 records of SGPools_svy21.csv. It consists of seven columns. The XCOORD and YCOORD columns are the x-coordinates and y-coordinates of SingPools outlets and branches. They are in [Singapore SVY21 Projected Coordinates System](https://www.sla.gov.sg/sirent/CoordinateSystems.aspx).

![](images/sgpools.jpeg)

## 8.2.2 Data Import and Preparation

The code chunk below uses read_csv() function of readr package to import SGPools_svy21.csv into R as a tibble data frame called sgpools.

```{r}
sgpools <- read_csv("data/aspatial/SGPools_svy21.csv")
```

After importing the data file into R, it is important for us to examine if the data file has been imported correctly.

The code chunk below shows list() is used to do the job.

```{r}
list(sgpools) 
```

Notice that the ***sgpools*** data in tibble data frame and not the common R data frame.

# 8.3 Creating a sf data frame from an aspatial data frame

The code chunk below converts sgpools data frame into a simple feature data frame by using st_as_sf() of sf packages

```{r}
sgpools_sf <- st_as_sf(sgpools, 
                       coords = c("XCOORD", "YCOORD"),
                       crs= 3414)
```

Things to learn from the arguments above:

-   The coords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.
-   The crs argument required you to provide the coordinates system in epsg format. [EPSG: 3414](https://epsg.io/3414) is Singapore SVY21 Projected Coordinate System. You can search for other country's epsg code by refering to [epsg.io](https://epsg.io/).

Figure below shows the data table of sgpools_sf. Notice that a new column called geometry has been added into the data frame.

![](images/sgpools2.jpeg)

You can display the basic information of the newly created sgpools_sf by using the code chunk below.

```{r}
list(sgpools_sf)
```

The output shows that sgppols_sf is in point feature class. It's epsg ID is 3414. The bbox provides information of the extend of the geospatial data.

# 8.4 Drawing Proportional Symbol Map

To create an interactive proportional symbol map in R, the view mode of tmap will be used.

The code churn below will turn on the interactive mode of tmap.

```{r}
tmap_mode("view")
```

## 8.4.1 It all started with an interactive point symbol map

The code chunks below are used to create an interactive point symbol map.

```{r}
tm_shape(sgpools_sf)+
tm_bubbles(col = "red",
           size = 1,
           border.col = "black",
           border.lwd = 1)
```

## 8.4.2 Lets make it proportional

To draw a proportional symbol map, we need to assign a numerical variable to the size visual attribute. The code chunks below show that the variable Gp1Gp2Winnings is assigned to size visual attribute.

```{r}
tm_shape(sgpools_sf)+
tm_bubbles(col = "red",
           size = "Gp1Gp2 Winnings",
           border.col = "black",
           border.lwd = 1)
```

## 8.4.3 Lets give it a different colour

The proportional symbol map can be further improved by using the colour visual attribute. In the code chunks below, OUTLET_TYPE variable is used as the colour attribute variable.

```{r}
tm_shape(sgpools_sf)+
tm_bubbles(col = "OUTLET TYPE", 
          size = "Gp1Gp2 Winnings",
          border.col = "black",
          border.lwd = 1)
```

# 8.5 Twin Brothers

An impressive and little-know feature of tmap's view mode is that it also works with faceted plots. The argument sync in tm_facets() can be used in this case to produce multiple maps with synchronised zoom and pan settings.

```{r}
tm_shape(sgpools_sf) +
  tm_bubbles(col = "OUTLET TYPE", 
          size = "Gp1Gp2 Winnings",
          border.col = "black",
          border.lwd = 1) +
  tm_facets(by= "OUTLET TYPE",
            nrow = 1,
            sync = TRUE)
```

Before you end the session, it is wiser to switch tmap's Viewer back to plot mode by using the code chunk below.

```{r}
tmap_mode("plot")
```

# Part Three: Analytical Mapping

# 9.1 Overview

## 9.1.1 Learning Outcomes
This hands-on exercise is designed to provide us with practical experience in applying the relevant R techniques for mapping analysis.
Upon completing this hands-on exercise, we will have the skills to utilise specific functions from tmap and tidyverse to accomplish the tasks below:

-   Importing geospatial data in rds format into the R environment.
-   Generating choropleth maps of cartographic quality with suitable tmap functions.
-   Developing a rate map.
-   Producing a percentile map.
-   Constructing a boxmap.

# 9.2 Getting Started

## 9.2.1 Installing and loading packages

```{r}
pacman::p_load(tmap, tidyverse, sf)
```

## 9.2.2 Importing data
For the purpose of this hands-on exercise, a prepared data set called NGA_wp.rds will be used. The data set is a polygon feature data.frame providing information on water point of Nigeria at the LGA level. You can find the data set in the rds sub-direct of the hands-on data folder.

```{r}
NGA_wp <- read_rds("data/rds/NGA_wp.rds")
```

# 9.3 Basic Choropleth Mapping
## 9.3.1 Visualising distribution of non-functional water point

Let's plot a choropleth map showing the distribution of non-function water point by LGA

```{r}
p1 <- tm_shape(NGA_wp) +
  tm_fill("wp_functional",
          n = 10,
          style = "equal",
          palette = "Blues") +
  tm_borders(lwd = 0.1,
             alpha = 1) +
  tm_layout(main.title = "Distribution of functional water point by LGAs",
            legend.outside = FALSE)
```

```{r}
p2 <- tm_shape(NGA_wp) +
  tm_fill("total_wp",
          n = 10,
          style = "equal",
          palette = "Blues") +
  tm_borders(lwd = 0.1,
             alpha = 1) +
  tm_layout(main.title = "Distribution of total  water point by LGAs",
            legend.outside = FALSE)
```

```{r}
tmap_arrange(p2, p1, nrow = 1)
```

# 9.4 Choropleth Map for Rates
In much of our readings we have now seen the importance to map rates rather than counts of things, and that is for the simple reason that water points are not equally distributed in space. That means that if we do not account for how many water points are somewhere, we end up mapping total water point size rather than our topic of interest.

## 9.4.1 Deriving Proportion of Functional Water Points and Non-Functional Water Points
We will tabulate the proportion of functional water points and the proportion of non-functional water points in each LGA. In the following code chunk, mutate() from dplyr package is used to derive two fields, namely pct_functional and pct_nonfunctional.

```{r}
NGA_wp <- NGA_wp %>%
  mutate(pct_functional = wp_functional/total_wp) %>%
  mutate(pct_nonfunctional = wp_nonfunctional/total_wp)
```

## 9.4.2 Plotting map of rate
Let's plot a choropleth map showing the distribution of percentage functional water point by LGA

```{r}
tm_shape(NGA_wp) +
  tm_fill("pct_functional",
          n = 10,
          style = "equal",
          palette = "Blues",
          legend.hist = TRUE) +
  tm_borders(lwd = 0.1,
             alpha = 1) +
  tm_layout(main.title = "Rate map of functional water point by LGAs",
            legend.outside = TRUE)
```

# 9.5 Extreme Value Maps
Extreme value maps are variations of common choropleth maps where the classification is designed to highlight extreme values at the lower and upper end of the scale, with the goal of identifying outliers. These maps were developed in the spirit of spatializing EDA, i.e., adding spatial features to commonly used approaches in non-spatial EDA (Anselin 1994).

## 9.5.1 Percentile Map
The percentile map is a special type of quantile map with six specific categories: 0-1%,1-10%, 10-50%,50-90%,90-99%, and 99-100%. The corresponding breakpoints can be derived by means of the base R quantile command, passing an explicit vector of cumulative probabilities as c(0,.01,.1,.5,.9,.99,1). Note that the begin and endpoint need to be included.

### 9.5.1.1 Data Preparation
Step 1: Exclude records with NA by using the code chunk below.

```{r}
NGA_wp <- NGA_wp %>%
  drop_na()
```

Step 2: Creating customised classification and extracting values

```{r}
percent <- c(0,.01,.1,.5,.9,.99,1)
var <- NGA_wp["pct_functional"] %>%
  st_set_geometry(NULL)
quantile(var[,1], percent)
```

:::callout-important
When variables are extracted from an sf data.frame, the geometry is extracted as well. For mapping and spatial manipulation, this is the expected behavior, but many base R functions cannot deal with the geometry. Specifically, the `quantile()` gives an error. As a result `st_set_geomtry(NULL)` is used to drop geomtry field.
:::

### 9.5.1.2 Why writing functions?
Writing a function has three big advantages over using copy-and-paste:

-   You can give a function an evocative name that makes your code easier to understand.
-   As requirements change, you only need to update code in one place, instead of many.
-   You eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).

Source: [Chapter 19: Functions of R for Data Science.](https://r4ds.had.co.nz/functions.html#functions)

### 9.5.1.3 Creating the get.var function
Firstly, we will write an R function as shown below to extract a variable (i.e. wp_nonfunctional) as a vector out of an sf data.frame.

* arguments
    + vname: variable name (as character, in quotes)
    + df: name of sf data frame
* returns
    + v: vector with values (without a column name)

```{r}
get.var <- function(vname,df) {
  v <- df[vname] %>% 
    st_set_geometry(NULL)
  v <- unname(v[,1])
  return(v)
}
```

### 9.5.1.4 A percentile mapping function
Next, we will write a percentile mapping function by using the code chunk below.

```{r}
percentmap <- function(vnam, df, legtitle=NA, mtitle="Percentile Map"){
  percent <- c(0,.01,.1,.5,.9,.99,1)
  var <- get.var(vnam, df)
  bperc <- quantile(var, percent)
  tm_shape(df) +
  tm_polygons() +
  tm_shape(df) +
     tm_fill(vnam,
             title=legtitle,
             breaks=bperc,
             palette="Blues",
          labels=c("< 1%", "1% - 10%", "10% - 50%", "50% - 90%", "90% - 99%", "> 99%"))  +
  tm_borders() +
  tm_layout(main.title = mtitle, 
            title.position = c("right","bottom"))
}
```

### 9.5.1.5 Test drive the percentile mapping function
To run the function, type the code chunk as shown below.

```{r}
percentmap("total_wp", NGA_wp)
```

Note that this is just a bare bones implementation. Additional arguments such as the title, legend positioning just to name a few of them, could be passed to customise various features of the map.

## 9.5.2 Box map
In essence, a box map is an augmented quartile map, with an additional lower and upper category. When there are lower outliers, then the starting point for the breaks is the minimum value, and the second break is the lower fence. In contrast, when there are no lower outliers, then the starting point for the breaks will be the lower fence, and the second break is the minimum value (there will be no observations that fall in the interval between the lower fence and the minimum value).

```{r}
ggplot(data = NGA_wp,
       aes(x = "",
           y = wp_nonfunctional)) +
  geom_boxplot()
```


-   Displaying summary statistics on a choropleth map by using the basic principles of boxplot.

-   To create a box map, a custom breaks specification will be used. However, there is a complication. The break points for the box map vary depending on whether lower or upper outliers are present.

### 9.5.2.1 Creating the boxbreaks function
The code chunk below is an R function that creating break points for a box map.

* arguments
    + v: vector with observations
    + mult: multiplier for IQR (default 1.5)
* returns
    + bb: vector with 7 break points compute quartile and fences

```{r}
boxbreaks <- function(v,mult=1.5) {
  qv <- unname(quantile(v))
  iqr <- qv[4] - qv[2]
  upfence <- qv[4] + mult * iqr
  lofence <- qv[2] - mult * iqr
  # initialize break points vector
  bb <- vector(mode="numeric",length=7)
  # logic for lower and upper fences
  if (lofence < qv[1]) {  # no lower outliers
    bb[1] <- lofence
    bb[2] <- floor(qv[1])
  } else {
    bb[2] <- lofence
    bb[1] <- qv[1]
  }
  if (upfence > qv[5]) { # no upper outliers
    bb[7] <- upfence
    bb[6] <- ceiling(qv[5])
  } else {
    bb[6] <- upfence
    bb[7] <- qv[5]
  }
  bb[3:5] <- qv[2:4]
  return(bb)
}
```

### 9.5.2.2 Creating the get.var function
The code chunk below is an R function to extract a variable as a vector out of an sf data frame.

* arguments
    + vname: variable name (as character, in quotes)
    + df: name of sf data frame
* returns
    + v: vector with values (without a column name)
    
```{r}
get.var <- function(vname,df) {
  v <- df[vname] %>% st_set_geometry(NULL)
  v <- unname(v[,1])
  return(v)
}
```

### 9.5.2.3 Test drive the newly created function
Let’s test the newly created function

```{r}
var <- get.var("wp_nonfunctional", NGA_wp) 
boxbreaks(var)
```

### 9.5.2.4 Boxmap function
The code chunk below is an R function to create a box map. 

* arguments
    + vnam: variable name (as character, in quotes)
    + df: simple features polygon layer
    + legtitle: legend title
    + mtitle: map title 
    + mult: multiplier for IQR
* returns
    + a tmap-element (plots a map)
```{r}
boxmap <- function(vnam, df, 
                   legtitle=NA,
                   mtitle="Box Map",
                   mult=1.5){
  var <- get.var(vnam,df)
  bb <- boxbreaks(var)
  tm_shape(df) +
    tm_polygons() +
  tm_shape(df) +
     tm_fill(vnam,title=legtitle,
             breaks=bb,
             palette="Blues",
          labels = c("lower outlier", 
                     "< 25%", 
                     "25% - 50%", 
                     "50% - 75%",
                     "> 75%", 
                     "upper outlier"))  +
  tm_borders() +
  tm_layout(main.title = mtitle, 
            title.position = c("left",
                               "top"))
}
```

```{r}
tmap_mode("plot")
boxmap("wp_nonfunctional", NGA_wp)
```
```